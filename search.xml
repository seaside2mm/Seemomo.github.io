<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【统计】python认识Q-Q图</title>
      <link href="/2020/05/05/2020/q-q-tu/"/>
      <url>/2020/05/05/2020/q-q-tu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我将写一篇文章，用一个动画图来解释Q图的意义。 我想试着解释一下这张图，因为这张图有点离奇，需要一些技巧来理解。在R中可以用qqnorm写出Q-Q图，但这是个黑匣子，不知道怎么操作，所以我自己用Python写的。</p><p>这次要使用公寓租金数据。</p><table><thead><tr><th style="text-align:left">Walk_min</th><th style="text-align:left">distance</th><th style="text-align:left">Price</th><th style="text-align:left">Type</th><th style="text-align:left">Area</th><th style="text-align:left">Direction</th><th style="text-align:left">Year</th><th></th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">8</td><td style="text-align:left">B</td><td style="text-align:left">7900</td><td style="text-align:left">1K</td><td style="text-align:left">30.03</td><td style="text-align:left">南</td><td>3</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">9</td><td style="text-align:left">B</td><td style="text-align:left">8500</td><td style="text-align:left">1K</td><td style="text-align:left">21.9</td><td style="text-align:left">南</td><td>5</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">10</td><td style="text-align:left">B</td><td style="text-align:left">10800</td><td style="text-align:left">1K</td><td style="text-align:left">27.05</td><td style="text-align:left">南</td><td>4</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">10</td><td style="text-align:left">B</td><td style="text-align:left">10800</td><td style="text-align:left">1K</td><td style="text-align:left">29.67</td><td style="text-align:left">南</td><td>4</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td><td>…</td></tr><tr><td style="text-align:left">185</td><td style="text-align:left">11</td><td style="text-align:left">B</td><td style="text-align:left">8600</td><td style="text-align:left">1K</td><td style="text-align:left">20.79</td><td style="text-align:left">北東</td><td>0</td></tr><tr><td style="text-align:left">186</td><td style="text-align:left">8</td><td style="text-align:left">B</td><td style="text-align:left">7100</td><td style="text-align:left">1K</td><td style="text-align:left">22</td><td style="text-align:left">西</td><td>17</td></tr><tr><td style="text-align:left">187</td><td style="text-align:left">9</td><td style="text-align:left">B</td><td style="text-align:left">18400</td><td style="text-align:left">1LDK</td><td style="text-align:left">54.68</td><td style="text-align:left">西</td><td>10</td></tr></tbody></table><p>您可以从这里的统计学考试二级官方教材中间的 &quot;资料下载 &quot;链接中下载。 解压下载的压缩文件，解压后在[第2章]-[文本]文件夹中解压出Mansion2.data，这就是我们要用到的数据。</p><p>而当你有了数据之后，首先要做的就是绘制图表，建立一个数据的图像。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehgtfug6sj30k90iomxa.jpg" alt=""></p><p>价格柱状图看出来靠近在左侧，下摆右侧。 另外价格和尺寸之间似乎有一定的关联性。</p><p>既然这个Q-Q图将重点关注价格，那么我们将尝试在价格上再进一步解读该图。也就是说，&quot;这个分布是否遵循正态分布？实际上，笔者根据这个数据得到的均值和标准差，应用正态分布的密度函数，如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehgw1ofqej30eg0axa9z.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehgwb658lj30dw0axjr8.jpg" alt=""></p><p>下面是绘制上述一系列图形的<a href="https://gist.github.com/seaside2mm/2365c53631e6f9b070b10197825ea266" target="_blank" rel="noopener">Python代码</a>。</p><h1>什么是Q-Q图？</h1><blockquote><p>From wiki</p><p>是在<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E8%AE%A1%E5%AD%A6" target="_blank" rel="noopener">统计学</a>中，通过比较两个概率分布的分位数对这两个概率分布进行比较的概率图方法。首先选定分位数的对应概率区间集合，在此概率区间上，点(x,y)对应于第一个分布的一个分位数x和第二个分布在和x相同概率区间上相同的分位数。因此画出的是一条含参数的曲线，参数为概率区间的分割数[<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E4%BD%8D%E5%9C%96#cite_note-1" target="_blank" rel="noopener">1]</a> 。</p><p>如果被比较的两个分布比较相似，则其分位图近似地位于<em>y</em> = <em>x</em>上。如果两个分布线性相关，则分位图上的点近似地落在一条直线上，但并不一定是<em>y</em> = <em>x</em>。分位图同样可以用来估计一个分布的位置参数。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehgy91k24j30e80chq2s.jpg" alt=""></p><p>是的，这是一个Q-Q图的数据 “价格”，也就是租金数据。 一眼看去，很难说清楚这张图显示的是什么。<br>为了给出一个课本上的解释，Q图是将得到的数据与理论上的分布进行比较，并考察它们的相似性。<strong>如果是相似的, 绘出的点在一条直线上。</strong></p><p>那么上图应该如何解读呢？<br>上述图4被认为是对图2的改动。 换句话说，该图直观地显示了正态分布密度函数的理论分布与得到的租金数据是否是一条直线，与所得到的租金数据有多相似。</p><h1>Q-Q图的结构</h1><p>现在，这张图应该是类似于理论上的线性分布，但我将解释一下为什么是这样的，因为我认为有必要了解如何绘制这张图。</p><p>所以我们再用租金数据来说明一下。 其分布的形状是这样的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehh1ofguwj30aj074a9u.jpg" alt=""></p><p>从这里开始，用两个中间的图形来绘制Q-Q图。</p><p>首先要做的是将这些租房数据按递减的顺序逐一摆放，并打点，画出这个租房数据的图形。 一共有188个数据，均匀间隔在0到1之间。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehh2b4634j30ce0aidfp.jpg" alt=""></p><p>作为第二张图，由于我们假设正态分布是理论上的正态分布，所以我们将写出并使用正态累积分布函数图。 这也是，这也代表了累积密度函数，188个点的累积密度函数与租金数据相等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehh2yykq5j30bu0ai745.jpg" alt=""></p><p>把这两个图形结合起来，我们可以写出一个Q-Q图的图形。 让我们用动画图来看看。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehh3gvraeg30hs0hsx6p.gif" alt=""></p><p>前两张图为此图右上和左下的中间过程图。 左上方是目标Q-Q图。 首先，右上角的租金数据图的横轴用分位数表示，左下角的正态累计分布函数的纵轴用分位数表示。 在右上角和左下角同时将这个量程从0滑到1。 用一条黑线表示。 黑线相交的点用红点表示。 这些红点同时被绘制出来，这就是Q-Q图。 点线代表的是它。<br>这个Q-Q图中的 &quot;Q &quot;代表 “分位数”，我认为它的名字来源于右上图和左下图中的分位数是同时移动的。</p><h1>按照正态分布的随机变量的Q-Q图</h1><p>现在，你说如果数据和理论分布相同，那么Q-Q图就会是一条直线，所以我也想尝试一下。 这意味着使用遵循正态分布的随机变量。<br>下面是一个由188个随机数组成的直方图，这些随机数遵循正态分布。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhbxn8gcj30aa0740si.jpg" alt=""></p><p>为了进一步说明Q-Q图…这绝对是一条直线，不是吗？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhcgq907g30hs0hs7wi.gif" alt=""></p><h1>按指数分布的随机变量的Q-Q图</h1><p>接下来是指数分布。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhdba2jkj30aa074q2p.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhdnntj0g30hs0hsu0x.gif" alt=""></p><p>在这样的形状中，正态Q-Q图的右下角会凸起。</p><h1>根据F分布的随机数的Q-Q图</h1><p>F型分布，下摆稍长，向右转。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhell2bhj30ab0740si.jpg" alt=""></p><p>这在右下角也有一个凸Q-Q图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhf32ne7g30hs0hsnpd.gif" alt=""></p><h1>根据β分布的随机数的Q-Q图</h1><p>接下来，我将用左边的长下摆类型的分布和α=6, β=2的β分布写出Q-Q图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhfui0hnj30ab074jr6.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhg0y63bg30hs0hs7wi.gif" alt=""></p><p>这时，在左上角画出一个凸Q-Q图。</p><p>变成是α=0.5和β=0.5的β分布，两边的顶点都是顶点。 在本例中，我们画了一个Q-Q图，下半部分右下角向中间凸，上半部分左上角向中间凸。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhgv1yq8j30ab0740si.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehhh2urosg30hs0hsu0x.gif" alt=""></p><p>本页描述的图形的完整Python代码可以在<a href="https://gist.github.com/seaside2mm/2365c53631e6f9b070b10197825ea266" target="_blank" rel="noopener">这里</a>找到.</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Python便利帳</title>
      <link href="/2020/05/01/wo-de-python-bian-li-zhang/"/>
      <url>/2020/05/01/wo-de-python-bian-li-zhang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考：<a href="https://qiita.com/kenmatsu4/items/569d618f0a7f87558d8e" target="_blank" rel="noopener">https://qiita.com/kenmatsu4/items/569d618f0a7f87558d8e</a></p><h1>時系列</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【统计学】可视化理解广义线性混合模型（GLMM）</title>
      <link href="/2020/05/01/python-guang-yi-xian-xing-hun-he-mo-xing/"/>
      <url>/2020/05/01/python-guang-yi-xian-xing-hun-he-mo-xing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我在《数据分析的统计建模导论》（注：「データ解析のための統計モデリング入門」）第157页中介绍了 &quot;混合分布 &quot;的概念，在这里，我尝试通过动画化的模拟，用随机数代替分布来形象化。</p><p>下面是一个结果的动画。 我们将在文中加以说明。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged62yftfkg30g00w0qjc.gif" alt=""></p><p>这里的代码</p><p>所有的详细讲解都是在书中中用通俗易懂的方式写出来的，所以我在这里只介绍一下如何形象化。 如果你觉得这个故事很有趣，请你买下它!</p><h1>序言</h1><p>在一株植物中，最多产生8粒种子，存活的种子数量是二项式分布。<br>$$<br>{p(y_i) ={8 \choose y_i}\ q_i^{y_i} (1-q_i)^{8-y_i} \quad \mbox{for}\ q_i=0,1,2,\dots,8<br>}<br>$$<br>其中，$y_i$是个体$i$中存活的种子数（观察到的），$q_i$是个体中$i$每个种子的存活概率。</p><p>同时，假设这个$q_i$具有不同的个体差异，用logistic函数表示。<br>$$<br>{q_i = {\rm logistic} (r_i)= {1 \over 1 + \exp( -r_i) }<br>}<br>$$<br>我们还假设这个Logistic函数的参数$r_i$遵循均值为0的正态分布，标准差$s$<br>$$<br>{r_i \sim N(0, s)<br>}<br>$$<br>换句话说，$r_i$的密度函数为<br>$$<br>{p(r_i | s) = {1 \over \sqrt{2\pi s^2} } \exp \left( -{r_i^2 \over 2s^2} \right)}<br>$$<br>而这被认为是$i$中的个体差异。</p><h1>试着将其形象化</h1><p>现在，我们先来举例说明一下个别差异$r_i∼N(0,s)$。 当标准差$s=4$时，根据正态分布产生10000个随机数。 那个直方图就是下面的浅蓝色条形图。 其中每一个都是用红线表示的逻辑函数。<br>$$<br>{q_i = {\rm logistic} (r_i)= {1 \over 1 + \exp( -r_i) }}<br>$$<br>转换为从0到1的值，即可以认为是一个概率值，即$q_i$。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged6atghalj30f90almx2.jpg" alt=""></p><p>既然我们能够将这些规则随机数中的每一个都转化为概率$q_i$，那么下面就用$q_i$的直方图来表示。 我们可以看到，这个分布是相当宽的、正态的，用对数函数进行变换后的效果是，它更接近于0和1。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged6bughgij30fa0al0sl.jpg" alt=""></p><p>所以，对于这10000个$q_i$中的每一个，我们对应一个二项式分布。二项式分布是<br>$$<br>{p(y_i) ={8 \choose y_i}\ q_i^{y_i} (1-q_i)^{8-y_i} \quad \mbox{for}\ q_i=0,1,2,\dots,8<br>}<br>$$<br>所以，每一个$q_i$的形状都是不同的，下面以[0.0、0.125、0.25、0.25、0.375、0.5、0.5、0.625、0.75、0.875、0.875、1.0] 9个值的$q_i$为例。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged6ddp1w6j30oa0g474f.jpg" alt=""></p><p>根据10000个$q_i$的值，我们生成大量的二项式分布，如上所述，并将其相加。<br>下面是加起来的结果。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged6e50igjj30f70al745.jpg" alt=""></p><p>我会试着做个动画。<br>在上一节中，我试着做了一个s=4的例子的图，下面的图，我也是在一开始就贴出了，当s从0到3连续移动时，显示了一个动画的情况。<br>在这个例子中，分布似乎从s=2左右向左和右移动。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged6ewz1z4g30g00w0qjc.gif" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【统计】python学统计学的基础知识</title>
      <link href="/2020/05/01/python-xue-tong-ji/"/>
      <url>/2020/05/01/python-xue-tong-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【统计】python标准偏差再讨论</title>
      <link href="/2020/05/01/2020/python-fang-chai-zai-tao-lun/"/>
      <url>/2020/05/01/2020/python-fang-chai-zai-tao-lun/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文来源：<a href="https://qiita.com/kenmatsu4/items/e6c6acb289c02609e619" target="_blank" rel="noopener">https://qiita.com/kenmatsu4/items/e6c6acb289c02609e619</a></p></blockquote><p>对于想学习统计学的人来说，有一个非常重要但又很难理解的概念就是 “标准差”。 对于 &quot;平均&quot;大家很熟悉，你以为 “我懂了，我懂了”，却突然出现了 “标准差”。<br>$$<br>{\sigma = \sqrt{ {1 \over n} \sum_{i=1}^n(x_i - \bar{x})^2}</p><p>}<br>$$<br>有的人可能会不知所措，觉得不会做。</p><p>如果看图的图像，下面的红线的长度就是 “标准差”。 我们也会发现，为什么这个长度是标准差。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged04sybxhg30hs0aowjg.gif" alt=""></p><p>代码06 <a href="https://gist.github.com/seaside2mm/87a2bbf5202726b0aa0bba1908cccee3" target="_blank" rel="noopener">这边</a></p><p>在这篇文章中，我将试着为不擅长数学的人讲解一下什么是标准差。<br>如果你理解了公式，但不知道 &quot;标准差 &quot;是什么意思，我们将用一种方式来解释，帮助你直观地理解它。</p><p>在这篇文章中，n作为标准差的分母，在某些情况下，根据所要分析的情况，也可以用n-1来表示，但在这里，我们将用比较简单的符号n来表示。</p><h1>1.平均</h1><p>我们再来考虑一次 “平均”。 平均数有不同类型，如 “算术平均数”、“几何平均数”、&quot;谐波平均数 &quot;等，但所谓的 &quot;平均数 &quot;就是大家熟悉的 “算术平均数”。</p><p>所以你把所有的数据加起来，再除以这个数字。 在统计学中，这个 &quot;均值 “被称为$\bar x$，定义如下 数据的数量假设为$n$。<br>$$<br>{\bar{x} = {1 \over n} \sum_{i=1}^{n} x_i<br>}<br>$$<br>用图表表示如下,这是很直观的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged0drpijrj30hu040q2q.jpg" alt=""></p><p>代码02 <a href="https://gist.github.com/seaside2mm/87a2bbf5202726b0aa0bba1908cccee3" target="_blank" rel="noopener">这边</a></p><h1>2. 什么是 &quot;偏差 &quot;？</h1><p>现在，下一步是对 &quot;偏差 &quot;概念的解释。Deviation, 偏差,是指每个数据与平均值之间的差值，如下图所示。 红线是每个数据的偏差。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged0hyg2enj30hu073jr8.jpg" alt=""></p><p>代码03 <a href="https://gist.github.com/seaside2mm/87a2bbf5202726b0aa0bba1908cccee3" target="_blank" rel="noopener">这边</a></p><h1>3. 平均偏差</h1><p>现在，在说到标准差之前，我先介绍一下 “平均偏差”，这很容易直观地理解。这是前文中介绍的 &quot;偏差 &quot;的平均数。 换句话说</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">偏差</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">-18</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">-15</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">-4</td></tr></tbody></table><p>但只有一个问题：如果你把它们全部加起来，就会得到0。<br>我想做的是上图红线长度的平均值，即</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged0osp30xj30hu073q2v.jpg" alt=""></p><p>因此，考虑将长度的负的部分倒转，即绝对值之后再平均。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged0rdlu2ej30hu073mx3.jpg" alt=""></p><p>取这些 &quot;偏差的绝对值 &quot;的平均值，结果是10.57，也就是所谓的 “平均偏差”。衡量你离平均水平有多远的一个指标。本例中，与平均分81分相差10.57分左右。可以毫不夸张地说，这个概念几乎是标准偏差的想法。 只是计算方法稍有不同而已。所以，当你说 &quot;标准差 &quot;的时候，你可以把它想成是 ==“它离平均数有多远的平均数”==。</p><p>公式表示：<br>$$<br>\frac{1}{n}\sum_{i=1}^n|\bar x - x|<br>$$<br>写成图形时，它的表示方法是这样的，斜率反转，使数值在x为负值的区域内为正值。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged0um10pvj30gq0acaa0.jpg" alt=""></p><h1>4. 标准偏差</h1><p>现在，终于，这篇文章的主角–“标准偏差”。<br>在 “平均偏差 &quot;中，我们用绝对值将负数变为正数，而在 &quot;标准偏差 &quot;中，我们用平方。换句话说，思路是完全一样的，只是去掉负号的方式不同。</p><p>从下面可以看到，原点是均值点，相似之处是将负值改为正值。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged14cu841j30gn0abjre.jpg" alt=""></p><p>在上一节中，与均值的差值用下图所示的线段长度来表示，</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged15iojifj30ew07cmx0.jpg" alt=""></p><p>这次用平方面积来评价与均值的差异，如图所示。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged165x2wxj30ei0eqmwz.jpg" alt=""></p><p>把这些区域加在一起，取平均数。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged16s0dp5j312w0t73zr.jpg" style="zoom: 33%;" /><p>公式表达为，<br>$$<br>{\sigma = \sqrt{ {1 \over n} \sum_{i=1}^n(x_i - \bar{x})^2}}<br>$$</p><h1>5. 与方差联系</h1><p>方差 说明数据的分散程度，可看做以面积为单位。 这时可以取根号，将面积变成它的长度。另外这也形象表示方差的sqaure的含义。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged1xo6z4mj312w0kcwg4.jpg" alt=""></p><pre class="line-numbers language-language-python"><code class="language-language-python">x = [96, 63, 85, 66, 91, 89, 77]ave = np.average(x)total = 0for i in range(len(x)):    total += (x[i] - ave)**2print np.sqrt(total/len(x))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，改成 &quot;平方 &quot;而不是 &quot;绝对值”的原因，这有点难以解释，但有一点是，用于平均偏差的绝对值在数学上很难处理，所以我们采用了容易处理的平方。 另外，我认为其中一个原因是，其中包含了几何中距离的概率。</p><p>一言以蔽之</p><ul><li>数学上的处理方式很方便。</li><li>距离的概念有平方和。</li></ul><h1>6.例</h1><p>##1：用图形理解</p><p>就像我在这篇文章的开头发的图。<br>这个数据的均值用红圈表示，逐一计算出每个数据的均值的偏差，再进一步计算出标准差，用红条的长度来表示。</p><p>所有数据的平均距离的平均值就是这个红条的长度。<br>标准差条的长度也会增加，因为数据是在一个大范围内发生的，所以标准差条的长度也会增加。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ged2kbz4klg30hs0aowjg.gif" alt=""></p><h2 id="2：偏差值">2：偏差值</h2><p>【注】日本高考只有偏差值，没有分数。</p><p>偏差值也是以 &quot;标准差 &quot;为基础。计算每个人参加考试的平均值和标准偏差。</p><ul><li>平均分的人偏离度为50。</li><li>得分比平均分高一个标准差的人的偏差为60。</li><li>得分低于平均分一个标准差的人，其偏差为40。</li></ul><p>按以下方法计算：<br>$$<br>{偏差値 = { (分数 - 平均) \over 标准偏差} \times 10 + 50<br>}<br>$$<br>该值的计算方法为如果你的分数高于上图中的红条长度的平均分，说明你的偏离度为60!</p><h1>最后</h1><p>你觉得怎么样？通过对标准差的理解，是不是统计学很有意思！如果越来越多的人对数据分析感兴趣，我会很高兴的!</p><p>如果有不明白的地方，请在评论区说出来!</p><p>我还写过一篇文章（幻灯片），叫《统计学基础》，如果你喜欢，请你把它作为相关文章来参考。<br><a href="http://qiita.com/kenmatsu4/items/5a59a7375140f29b31c2" target="_blank" rel="noopener">http://qiita.com/kenmatsu4/items/5a59a7375140f29b31c2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D视觉学习路线</title>
      <link href="/2020/05/01/2020/san-wei-shi-jue-xue-xi-lu-xian/"/>
      <url>/2020/05/01/2020/san-wei-shi-jue-xue-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>课程</h1><p><strong>01</strong></p><p>Stanford CS231A: Computer Vision-From 3D Reconstruction to Recognition</p><p>该课程介绍计算机视觉的概念和应用。主题包括：相机和投影模型、低层次的图像处理方法，如滤波和边缘检测，中等层次的视觉处理，如分割和聚类，以及高层次的视觉处理，如物体识别、场景识别、人脸检测和人体运动分类和三维重建等。需要的基础知识有：线性代数、基本概率和统计。</p><p><a href="https://github.com/dianyunPCL/multi_view_geometry/tree/master/cs231a-notes" target="_blank" rel="noopener">https://github.com/dianyunPCL/multi_view_geometry/tree/master/cs231a-notes</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gecphwqeo2j30u00dgdh9.jpg" alt="fh8uyw22ao"></p><p><strong>02</strong></p><p>UCSD CSE291-I00: Machine Learning for 3D Data</p><p>​      这是一门研究生水平的课程，涵盖计算机视觉和机器学习中使用的几何相关内容的核心概念和算法。课程讲师是Hao su ,主要介绍几何微分的概念、计算机几何图形学、视觉和机器学习中的应用，特别是深度学习部分。其中一半是讲师授课，一半是学生完成项目的演示，非常值得学习。需要的基础知识：线性代数、优化、机器学习等基础知识。</p><p><a href="https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/UCSD%20CSE291-I00%20Machine%20Learning%20for%203D%20Data" target="_blank" rel="noopener">https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/UCSD CSE291-I00 Machine Learning for 3D Data</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gecpil2ckbj30u00ccabf.jpg" alt="gem37btz6x"></p><p><strong>03</strong></p><p>Stanford CS468: Machine Learning for 3D Data</p><p>​      该课程将探讨在3D数据分析和合成方面，有监督和无监督机器学习的最新算法。在简单介绍几何基础和表示方法之后，重点介绍将机器学习方法用于3D形状分类、分割和对称检测，以及新的形状合成。以及研究点云或几何图形形式数据的深层神经架构，和将语义信息与对象模型关联的架构。最后将介绍三维形状设计的生成模型，例如生成自适应的对抗网络（GANs）。课程的数据源包括公共三维模型库（如Trimble 3D Warehouse或Yobi3D）和标记的语义信息的数据库（如ShapeNet）。</p><p><a href="http://graphics.stanford.edu/courses/cs468-17-spring/" target="_blank" rel="noopener">http://graphics.stanford.edu/courses/cs468-17-spring/</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gecpitsu4vj30u00blgmf.jpg" alt="l00bszb1nw"></p><p><strong>04</strong></p><p>MIT 6.838: Shape Analysis</p><p>​      该课程介绍分析几何数据所需的数学、算法和统计工具，以及在计算机图形学、计算机视觉、医学成像、机器学习、建筑等领域的应用。包括了：微分几何的应用介绍；曲率的离散概念；通过有限元方法（FEM）和离散外部微积分（DEC）等</p><p><a href="https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/MIT%206.838%20Shape%20Analysis" target="_blank" rel="noopener">https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/MIT 6.838 Shape Analysis</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gecpj4gqibj30u0070t93.jpg" alt="vt6s0hql3m"></p><p>05</p><p>Princeton <a href="https://cloud.tencent.com/product/cos?from=10680" target="_blank" rel="noopener">COS</a> 526: Advanced Computer Graphics</p><p>​      本课程将学习计算机图形学中的高级课题，包括计算摄影、几何建模、形状分析和图像渲染等方法。</p><p><a href="https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/Princeton%20COS%20526%20Advanced%20Computer%20Graphics" target="_blank" rel="noopener">https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/Princeton COS 526 Advanced Computer Graphics</a></p><p><strong>06</strong></p><p>Princeton CS597: Geometric Modeling and Analysis</p><p>三维数据数据库在计算机图形学、计算机辅助设计、分子生物学、古生物学和医学等多个领域变得越来越普遍。本课程将学习几何分析和从这些数据库中检索三维形状的算法。研究的重点将是匹配、配准、识别、分类、聚类、分割和理解3D数据的方法。</p><p><a href="https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/Princeton%20CS597%20Geometric%20Modeling%20and%20Analysis" target="_blank" rel="noopener">https://github.com/dianyunPCL/deep_learning-point-cloud/tree/master/Princeton CS597 Geometric Modeling and Analysis</a></p><p><strong>07</strong></p><p>Geometric Deep Learning</p><p>​      在过去的十年中，深度学习方法（例如卷积神经网络和循环神经网络）允许在各种不同领域（例如计算机视觉和<a href="https://cloud.tencent.com/product/asr?from=10680" target="_blank" rel="noopener">语音识别</a>）产生的广泛问题上实现前所未有的性能。尽管获得了这些结果，但迄今为止，对DL技术的研究主要集中在欧几里得域（即网格）上定义的数据上。然而，在许多不同的领域，例如：生物学、物理学、网络科学、推荐系统和计算机图形学；人们可能需要处理非欧几里得域（即图形和流形）上定义的数据。直到最近，在这些特定领域采用深度学习的做法一直滞后，主要是因为数据的非欧几里得性质使得基本运算（如卷积）的定义变得相当难以捉摸。几何深度学习从这个意义上讲是将深度学习技术扩展到图形/流形结构数据。</p><p><a href="http://geometricdeeplearning.com/" target="_blank" rel="noopener">http://geometricdeeplearning.com/</a></p><h1>库</h1><h2 id="Open3D">Open3D</h2><h2 id="PyTorch3D">PyTorch3D</h2>]]></content>
      
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【统计】python的中心极限定理再认识</title>
      <link href="/2020/04/29/2020/python-de-zhong-xin-ji-xian-ding-li-zai-ren-shi/"/>
      <url>/2020/04/29/2020/python-de-zhong-xin-ji-xian-ding-li-zai-ren-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文来源：<a href="https://qiita.com/kenmatsu4/items/351284ef430bcfd2c8ed" target="_blank" rel="noopener">https://qiita.com/kenmatsu4/items/351284ef430bcfd2c8ed</a></p><hr><h1>1.中心極限定理</h1><p>如果你研究统计学，你一定会看到一个比较生硬的名字–中心极限定理。</p><p>根据维基百科的说法。</p><blockquote><p><strong>中心极限定理</strong>是<a href="https://zh.m.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA" target="_blank" rel="noopener">概率论</a>中的一组定理。中心极限定理说明，在适当的条件下，大量相互独立<a href="https://zh.m.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">随机变量</a>的均值经适当标准化后<a href="https://zh.m.wikipedia.org/wiki/%E4%BE%9D%E5%88%86%E5%B8%83%E6%94%B6%E6%95%9B" target="_blank" rel="noopener">依分布收敛</a>于<a href="https://zh.m.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83" target="_blank" rel="noopener">正态分布</a>。这组定理是<a href="https://zh.m.wikipedia.org/wiki/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%AD%A6" target="_blank" rel="noopener">数理统计学</a>和误差分析的理论基础，指出了大量随机变量之和近似服从正态分布的条件。</p></blockquote><p>但我不太明白…<br>无论原始分布是什么，从它中抽取的样本均值都会接近正态分布。 样本方差也将接近于正态分布。 (准确地说，如果根据卡方分布，如果N大，可以用正态分布来近似)。</p><p>我想即使我们用语言解释，或者用公式证明（乘积率参数函数匹配之类的东西），也无法直观的理解它，所以本文的目的是想通过作图来尝试理解它。</p><p>更多理论内容，<a href="%5Bhttps://zh.m.wikipedia.org/zh-hans/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86%5D(https://zh.m.wikipedia.org/zh-hans/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86)">参考wiki</a></p><h1>2. 准备作图</h1><p>我们将用Python编写一个图形，准备过程如下。<br>本节提供了导入各种库和绘制图形的功能。</p><pre class="line-numbers language-language-python"><code class="language-language-python">%matplotlib inlineimport matplotlib.pyplot as pltimport numpy as npimport numpy.random as rdimport matplotlib.mlab as mlabimport scipy.stats as st# 参数n = 10000sample_size = 10000# 计算样本均值方差的函数def sample_to_mean_var(sample):    mean = np.mean(sample)    var  = np.var(sample)    return [mean, var]# 画图def plot_mean_var(stats, dist_name=""):    mu = stats[:,0]    var = stats[:,1]    bins = 40    # 均值图    plt.figure(figsize=(7,5))    plt.hist(mu, bins=bins, density=True, color="plum")    plt.title("mu from %s distribution"%(dist_name))    plt.show()    # 方差图    plt.figure(figsize=(7,5))    plt.hist(var, bins=bins, color="lightblue", density=True)    plt.title("var from %s distribution"%(dist_name))    plt.show()def plot_dist(data, bins, title =""):    plt.figure(figsize=(7,5))    plt.title(title)    plt.hist(data, bins, color="lightgreen", density=True)    plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>3. 绘图</h1><h2 id="指数分布">指数分布</h2><p>首先，让我们尝试一下指数分布。 下图是参数λ为0.1、10000个样本的指数分布图。 它是一个完全不对称的分布，右边是长长的下摆。</p><pre class="line-numbers language-language-python"><code class="language-language-python">lam = 0.1  x = rd.exponential(1./lam, size=sample_size)plot_dist(x, 100, "exponential dist")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geajan90yej30c208vq2t.jpg" alt="下载"></p><p>以这组10000个样本为一组，由这里计算出样本均值和样本方差。 在重复10,000次后，写出样本平均数和样本方差的直方图，我们得到如下结果.</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 由指数分布生成的样本lam = 0.1stats = np.array([sample_to_mean_var(rd.exponential(1./lam, size=sample_size)) for i in range(n)])plot_mean_var(stats, dist_name="exponential")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geaj6caq75j30c208ydfo.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geajemi01mj30c608yq2u.jpg" alt=""></p><p>我不知道，原来的分布相当偏斜，但样本均值和样本方差似乎是一个美丽的对称钟形。 中心极限定理是，样本均值和方差遵循正态分布。</p><p>下面，我也用其他的分布图来试试。</p><h2 id="卡方分布">卡方分布</h2><pre class="line-numbers language-language-python"><code class="language-language-python"># 自由度5df = 5x = rd.chisquare(df, sample_size)plot_dist(x, 50, "chi square dist")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F50670%2F50d746b4-8b89-b199-9047-70910576c877.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;w=1400&amp;fit=max&amp;s=db9f98cc504dedb6c8c638fef702d8a9" alt=""></p><pre class="line-numbers language-language-python"><code class="language-language-python">df = 5   # 自由度chi_stats = np.array([sample_to_mean_var(rd.chisquare(df, sample_size)) for i in range(n)])plot_mean_var(chi_stats, dist_name="chi square")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geajic7kz8j30by08y0sk.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geajid5tu4j30c108yt8j.jpg" alt=""></p><h2 id="双峰正态分布">双峰正态分布</h2><p>我也会尝试一下奇形怪状的分布，比如两座山。</p><pre class="line-numbers language-language-python"><code class="language-language-python"># 双峰正規分布def generate_bimodal_norm():    x = np.random.normal(0, 4, sample_size)    y = np.random.normal(25, 8, sample_size)    return np.append(x,y)z = generate_bimodal_norm()plot_dist(z, 70, "bi-modal normal dist")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geajk2bpkrj30c308y0sk.jpg" alt=""></p><pre class="line-numbers language-language-python"><code class="language-language-python">binorm_stats = np.array([sample_to_mean_var(generate_bimodal_norm()) for i in range(n)])plot_mean_var(binorm_stats, dist_name="bi-modal normal")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即使是这样的分布，样本均值或样本方差也是正态分布。 すごい，中心极限定理。</p><p>＃4.结论<br>于是，我试着通过看图来直观地理解中心极限定理，虽然看公式和证明，似乎很难。 这也是正态分布在统计学中如此重要的原因:smile:</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【统计】python的正态分布再认识</title>
      <link href="/2020/04/29/2020/python-de-zheng-tai-fen-bu-zai-ren-shi/"/>
      <url>/2020/04/29/2020/python-de-zheng-tai-fen-bu-zai-ren-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文来源：<a href="https://qiita.com/kenmatsu4/items/74b8a9f696507af410a4" target="_blank" rel="noopener">https://qiita.com/kenmatsu4/items/74b8a9f696507af410a4</a></p><hr><p>在统计学中，正态分布起着非常重要的作用。 表示正态分布（密度函数）的公式为<br>$$<br>{\Phi(x) = \frac{1}{\sqrt{2\pi\sigma^2}}\exp \left( -\frac{(x-\mu)^2}{2\sigma^2} \right)<br>}<br>$$<br>但这是一个非常复杂的公式…当方差$σ^2=1$，均值$μ=0$的标准正态分布时，看起来就简单多了。</p><p>$$<br>{\phi(x) = \frac{1}{\sqrt{2\pi}}\exp \left( -\frac{x^2}{2} \right)<br>}<br>$$<br><a href="https://gist.github.com/seaside2mm/143dd229620781b0d29f88df714985d6" target="_blank" rel="noopener">python</a>作图则是如下钟型：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geahrz6gafj30ag0743yh.jpg" alt=""></p><p>正态分布是平滑的、对称的。正态分布是用一个函数来表示连续概率，可以直观表现聚集在一点上的概率。<br>于是，用<a href="https://gist.github.com/seaside2mm/0f6a94221e5f18f43dbecf69c1aa3e12" target="_blank" rel="noopener">python</a>看看二次函数的图像，<br>$$<br>{f(x) = -x^2<br>}<br>$$<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geahzen1iaj30af074t8m.jpg" alt=""></p><p>越来越像了。 把它放在e的上面，做成一个钟的形状,<a href="https://gist.github.com/seaside2mm/6da6c795c4f66979de6d862ff9b85234" target="_blank" rel="noopener">python</a>表示。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geai4gqx1hj30aa06zt8m.jpg" alt=""></p><p>形状已经完全是正态分布。 这个正态分布的原始形式是$e^{-x^2}$。</p><p>此后，为了便于计算微分时的计算，$x$是$1/\sqrt{2}$。 换句话说，转换变量为$y = \sqrt{2}x$。<br>$$<br>{g(y) = \exp \left(-\frac{y^2}{2} \right)<br>}<br>$$<br><a href="https://gist.github.com/seaside2mm/40dc4123d5f365cf253082603ba97e08" target="_blank" rel="noopener">对比图</a>如下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geai92qy7ij30aa06zdfx.jpg" alt=""></p><p>它稍微向旁边扩散了一下。</p><p>为了让这个$f(x)$的面积为1(因为它是一个概率，所以所有可能发生的事件加起来都是100%)，我们需要把积分成1。</p><p>由<a href="%5Bhttps://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E7%A7%AF%E5%88%86%5D(https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E7%A7%AF%E5%88%86)">高斯积分（见维基百科）</a>可知，$x$的整个范围内的积分值为<br>$$<br>{\int_{-\infty}^{\infty} e^{-x^2}dx = \sqrt{\pi}<br>}<br>$$<br>所以，带入上面转换变量，<br>$$<br>{\int_{-\infty}^{\infty} \exp \left( {-\frac{y^2}{2}}\right)dy = \sqrt{2\pi}<br>}<br>$$<br>两边除以$2π$,<br>$$<br>{\int_{-\infty}^{\infty} \frac{1}{\sqrt{2\pi}} \exp \left( {-\frac{y^2}{2}}\right)dy = １<br>}<br>$$<br>我们得到了标准正态分布的公式:blush:</p><pre class="line-numbers language-language-python"><code class="language-language-python">import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3,3, 500)y1 = np.exp(-(x**2))y2 = np.exp(-(x**2)/2)y3 = (1/np.sqrt(2*np.pi))*np.exp(-(x**2)/2)plt.xlim(-3,3)plt.ylim(0,1.1)         plt.plot(x,y1,"b", label="exp(-x^2)")plt.plot(x,y2,"g", label="exp(-(x^2)/2")plt.plot(x,y3,"r", label="normal")plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geaih8vzbhj30gh0a3mxl.jpg" alt=""></p><p>这个公式是在$e^{-x^2}$的基础上，经过调整，如果把它积分面积就会是1。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【统计】python直观化正态分布与卡方分布的关系</title>
      <link href="/2020/04/29/2020/python-zhi-guan-hua-zheng-tai-fen-bu-yu-qia-fang-fen-bu-de-guan-xi/"/>
      <url>/2020/04/29/2020/python-zhi-guan-hua-zheng-tai-fen-bu-yu-qia-fang-fen-bu-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文来源：<a href="https://qiita.com/kenmatsu4/items/b6318d66fcfe78b84d83" target="_blank" rel="noopener">https://qiita.com/kenmatsu4/items/b6318d66fcfe78b84d83</a></p><hr><p>这是统计学可视化系列的第三弹。</p><h2 id="卡方分布嘛回事">卡方分布嘛回事</h2><p>在AB检验中经常使用的是卡方分布（<strong>chi-square distribution</strong>），如卡方检验。 如果把它画成图，它的样子如下，形状根据k的值变化，叫做自由度。</p><p>k个独立的标准正态分布变量的平方和服从自由度为k的卡方分布。卡方分布是一种特殊的伽玛分布，是统计推断中应用最为广泛的概率分布之一，例如假设检验和置信区间的计算。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geajte56bkg30hs0ao0uv.gif" alt=""></p><p><a href="https://gist.github.com/seaside2mm/48db46fcc6133bf6cc8d7884221153eb" target="_blank" rel="noopener">绘图代码</a></p><p>若k个随机变量${\displaystyle Z_{1}}、……、{\displaystyle Z_{k}}$是相互独立，符合标准正态分布的随机变量（数学期望为0、方差为1），则随机变量$Z$的平方和<br>$$<br>Z = \sum_{i = 1}^k X_i^2<br>$$<br>被称为服从<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%BA%A6_(%E7%BB%9F%E8%AE%A1%E5%AD%A6)" target="_blank" rel="noopener">自由度</a>为 <em>k</em> 的<strong>卡方分布</strong>.</p><hr><p>嗯，那是什么意思？ 在对正态分布的密度函数进行正态分布的平方？ 显然不是。</p><p>首先，既然我们说的是 “独立地遵循标准正态分布的k个随机变量”，那么我就试着写出一个遵循标准正态分布的随机数的直方图，30000 个服从$X∼ N(μ,σ)$的样本。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geak3egh5mj30bx08ywed.jpg" alt=""></p><p><a href="https://gist.github.com/seaside2mm/ac1ea9b345ef748fc366a44c139d3aea" target="_blank" rel="noopener">作图代码</a>参考第二弹，中心极限定理。</p><pre class="line-numbers language-language-python"><code class="language-language-python">x = np.random.normal(0, 1, 30000)plot_dist(x, bins=80, title="normal distribution.")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="自由度1">自由度1</h2><p>根据这个随机数的分布，用这个随机数的平方来绘制的随机数的分布，就是 chi-square分布。 在代码中。</p><pre class="line-numbers language-language-python"><code class="language-language-python">from scipy.stats import chi2x = np.random.normal(0, 1, 30000)x2 = x**2plt.figure(figsize=(7,5))plt.title("chi2 distribution.[k=1]")plt.hist(x2, 80, color="lightgreen", density=True)# 自由度1的卡方分布xx = np.linspace(0, 25 ,1000)plt.plot(xx, chi2.pdf(xx, df=1), linewidth=2, color="r")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geak9wlzogj30f00c1web.jpg" alt=""></p><p>如果你查看此图，你会看到以下内容:<br>因为平方，x为正数，所以所有的东西都向右移动，而不是$x=0$，并且<br>既然是平方的。</p><ul><li>$x&lt;1$，其中x小于1，被推到左边，向0倾斜。</li><li>$x≥1$，其中大于1的地方向右延伸，向$∞$侧靠拢这</li></ul><p>同时，我在画出1个自由度为1的chi-square分布的密度函数的线，基本一致!<br>因为只有一个$x$，所以我们有一个自由度为1的chi-square分布。</p><h2 id="更多自由度">更多自由度</h2><p>从2个变量为<br>$$<br>X_1^2 + X_2^2<br>$$<br>到10个变量<br>$$<br>\sum_{i = 1}^{10} X_i^2<br>$$<br>你可以看到下面的动画模拟</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geakgteq29g30g00cg75h.gif" alt=""></p><p>bravo!</p><p>我想，&quot;平方&quot;chi-square可以理解为对一个遵循标准正态分布的随机数进行平方化！</p><p>代码如下。</p><pre class="line-numbers language-language-python"><code class="language-language-python">from matplotlib import animation as anidef animate(nframe):    n = 30000    k = nframe + 1    cum = np.zeros(n)    for i in range(k):        x = np.random.normal(0, 1, n)        x2 = x**2        cum += x2     plt.clf()    #plt.figure(figsize=(9,7))    plt.ylim(0, 0.6)    plt.xlim(0, 25)    plt.title("chi2 histgram & pdf [k=%d]"%k)    plt.hist(cum, 80, color="lightgreen", normed=True)    # 自由度1    xx = np.linspace(0, 25 ,1000)    plt.plot(xx, chi2.pdf(xx, df=k), linewidth=2, color="r")fig = plt.figure(figsize=(10,8))anim = ani.FuncAnimation(fig, animate, frames=10, blit=True)anim.save('chi2_hist_dist.gif', writer='imagemagick', fps=1, dpi=64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>代码补编</li></ul><p>我们使用imagemagick来绘制GIF动画，请参考<a href="http://www.imagemagick.org/script/binary-releases.php" target="_blank" rel="noopener">HP</a>と<a href="http://www.imagemagick.org/download/python/" target="_blank" rel="noopener">PythonMagick</a>来安装。</p><p>不过，根据你的环境不同，ImageMagick和PythonMagick的安装并不容易，所以如果你只是想轻松制作一个动画，可以不需要额外的mp4动画库就可以制作一个动画，如下图所示。</p><pre class="line-numbers language-language-python"><code class="language-language-python">anim.save('filename.mp4', fps=13)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书清单</title>
      <link href="/2019/11/05/2019/du-shu-qing-dan/"/>
      <url>/2019/11/05/2019/du-shu-qing-dan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>书籍推荐</h1><p><em>Android创新实验室(AI+移动互联) 整理制作</em></p><blockquote><p>声明：所有pdf资源均来自网络，不保证内容与书名匹配，请在阅读之前注意辨识。强烈建议阅读纸质版书籍。</p><p>本项目仅供学习交流使用，如有侵权，烦请告知以便删除。</p></blockquote><p><img src="./img/bookv2.jpg" alt="BOOK"></p><h2 id="数学-进阶">数学(进阶)</h2><ul><li><p>《概率论与数理统计》陈希孺 著<a href="https://pan.baidu.com/s/1eQpMh5C" target="_blank" rel="noopener">PDF</a></p></li><li><p>《矩阵分析与应用》张贤达<a href="https://vdisk.weibo.com/s/FlmEhSJru6BA-" target="_blank" rel="noopener">PDF</a></p></li><li><p>《普林斯顿微积分读本》<a href="https://u19794310.ctfile.com/fs/19794310-372441496" target="_blank" rel="noopener">PDF</a></p></li><li><p>《应用近世代数 第3版》胡冠章 著<a href="http://gen.lib.rus.ec/book/index.php?md5=1AAB5F8A6FA6C8E0F1FCC5EF57FEA27E" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Convex Optimization》by Stephen Boyd<a href="http://www.weiyoou8.com/share/19165079.html" target="_blank" rel="noopener">PDF</a></p></li></ul><h2 id="编程语言">编程语言</h2><ul><li><p><strong>C语言</strong></p></li><li><p>《C Primer Plus》(入门 )<a href="https://pan.baidu.com/s/1gdDBP9T" target="_blank" rel="noopener">PDF</a></p></li><li><p>《C和指针》经典<a href="https://pan.baidu.com/s/1hJPjo" target="_blank" rel="noopener">PDF</a></p></li><li><p><strong>C++</strong></p></li><li><p>《C++ Primer Plus》(适合无C语言基础入门)<a href="https://pan.baidu.com/s/1nv7J92L" target="_blank" rel="noopener">PDF</a></p></li><li><p>《C++ Primer》(提高)<a href="https://pan.baidu.com/s/1sk21Ahf" target="_blank" rel="noopener">PDF</a></p></li><li><p>《The C++ Programming Language》权威<a href="https://pan.baidu.com/s/12o2k" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Effective Modern C++》C++11/14<a href="https://pan.baidu.com/s/1ntLAe9b" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Modern C++ Tutorial C++ 11/14/17/20 On the Fly》高速上手C++11/14教程<a href="https://changkun.de/modern-cpp/pdf/modern-cpp-tutorial-zh-cn.pdf" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Exceptional C++：47个C++工程难题、编程问题和解决方案》<a href="http://book.ucdrs.superlib.net/views/specific/2929/bookDetail.jsp?dxNumber=161000060558&amp;d=92343AD49EC75EE09FBD907665AB1873" target="_blank" rel="noopener">PDF</a></p></li><li><p><strong>Java</strong></p></li><li><p>《Head First Java》(入门)<a href="https://pan.baidu.com/s/1qX2ghe0#list/path=%2F" target="_blank" rel="noopener">PDF</a></p></li><li><p>《疯狂Java讲义》<a href="https://pan.baidu.com/s/12pR78" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Java编程思想》<a href="http://vdisk.weibo.com/s/uvlsIKkNoLEAy" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Java核心技术》<a href="https://pan.baidu.com/s/1o8CY6ro" target="_blank" rel="noopener">PDF1</a>、<a href="https://pan.baidu.com/share/link?shareid=3803014521&amp;uk=4245516461" target="_blank" rel="noopener">PDF2</a></p></li><li><p>《Effective Java》第3版<a href="https://pan.baidu.com/s/12mCVX" target="_blank" rel="noopener">PDF</a></p></li><li><p><strong>Python</strong></p></li><li><p>《Python编程入门到实践[美]》(入门)<a href="https://pan.baidu.com/s/1pKCFlaz" target="_blank" rel="noopener">PDF</a></p></li><li><p>《流畅的Python》进阶<a href="https://pan.baidu.com/s/1i4ZtSWl" target="_blank" rel="noopener">PDF</a></p></li></ul><h2 id="Android开发">Android开发</h2><ul><li><p>《第一行代码Android》第2版(入门)<a href="https://pan.baidu.com/s/1hrXnSji" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Android编程权威指南》(提升)<a href="https://pan.baidu.com/s/1mgtPkko" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Android开发艺术探索》(进阶)<a href="https://pan.baidu.com/s/1o8iseiI" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Android源码设计模式解析与实战》<a href="https://pan.baidu.com/s/1nuHywnZ" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Kotlin编程权威指南》</p></li><li><p>《Android群英传》<a href="https://pan.baidu.com/s/1c2uNF7U" target="_blank" rel="noopener">PDF</a></p></li></ul><h2 id="算法">算法</h2><ul><li><p>《算法导论》第3版<a href="https://pan.baidu.com/s/1c0lJmPq" target="_blank" rel="noopener">PDF</a></p></li><li><p>《数据结构与算法分析》经典<a href="https://pan.baidu.com/share/link?shareid=2040099117&amp;uk=2268417160&amp;fid=4143774584" target="_blank" rel="noopener">PDF</a></p></li><li><p>《多维与度量数据结构基础[美]》<a href="http://book.ucdrs.superlib.net/views/specific/2929/bookDetail.jsp?dxNumber=000008094272&amp;d=0DF294181E398C1CE8E6017AC0BB2D39" target="_blank" rel="noopener">PDF</a></p></li><li><p>《算法》第4版（Java描述）<a href="http://vdisk.weibo.com/s/AcSJGKVz_XiVt" target="_blank" rel="noopener">PDF</a></p></li><li><p>《算法笔记》(胡凡，曾磊 编)<a href="https://pan.baidu.com/s/130HH-tWlXxU22HRQ8-lHhA" target="_blank" rel="noopener">PDF</a></p></li><li><p>《挑战程序设计竞赛》<a href="https://pan.baidu.com/s/1c2GeKik" target="_blank" rel="noopener">PDF</a></p></li><li><p>《算法竞赛入门经典》第2版<a href="https://pan.baidu.com/s/1c2w0cKC" target="_blank" rel="noopener">PDF</a></p></li></ul><h2 id="计算机视觉">计算机视觉</h2><ul><li><p>《数字图像处理》冈萨雷斯 著<a href="https://pan.baidu.com/s/10eGz6" target="_blank" rel="noopener">PDF</a></p></li><li><p>《计算机视觉——算法与应用》经典<a href="https://vdisk.weibo.com/s/AcSJGKVz_Xj0s" target="_blank" rel="noopener">PDF</a></p></li><li><p>《视觉机器学习20讲》<a href="http://book.ucdrs.superlib.net/views/specific/2929/bookDetail.jsp?dxNumber=000015449959&amp;d=2CE333758A3E452AD1455DFF31C7F259" target="_blank" rel="noopener">PDF</a></p></li><li><p>《视觉SLAM十四讲 从理论到实践》第2版</p></li><li><p>《图像处理、分析与机器视觉》第4版<a href="https://pan.baidu.com/s/10eGz6" target="_blank" rel="noopener">PDF</a></p></li><li><p>《计算机视觉模型、学习和推理》<a href="http://book.ucdrs.superlib.net/views/specific/2929/bookDetail.jsp?dxNumber=000016661170&amp;d=603652CF34D1D8C13E5F7BCACCA4CFDB" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Multiple view geometry in computer vision》第2版<a href="https://vdisk.weibo.com/s/daQjrTsJChAzC" target="_blank" rel="noopener">PDF</a></p></li><li><p><strong>编程</strong></p></li><li><p>《Python计算机视觉编程》<a href="https://pan.baidu.com/s/1slUtBC5" target="_blank" rel="noopener">PDF</a></p></li><li><p>《学习OpenCV3》经典</p></li><li><p>《OpenCV3编程入门》(毛星云编)<a href="https://pan.baidu.com/s/1nvg4au9" target="_blank" rel="noopener">PDF</a></p></li><li><p>《OpenCV算法精解：基于Python与C++》</p></li><li><p>《OpenGL 超级宝典 第五版》<a href="https://pan.baidu.com/s/17R1Vb5hn8RGMngbGbhz_Hw" target="_blank" rel="noopener">PDF-EN</a>、<a href="https://pan.baidu.com/s/1O0louAI021S-OmJq03jf9Q" target="_blank" rel="noopener">PDF-CN</a></p></li><li><p>《OpenGL ES 3.0 编程指南》<a href="https://pan.baidu.com/s/1jCjn4uJfTeeyQsCSveux8Q" target="_blank" rel="noopener">PDF</a></p></li><li><p>《OpenGL ES 应用开发实践指南 Android 卷》<a href="https://pan.baidu.com/s/1270Db97XJOOuLz5F5022MQ" target="_blank" rel="noopener">PDF</a></p></li><li><p>《The Book of Shaders》<a href="https://thebookofshaders.com/" target="_blank" rel="noopener">PDF</a></p></li></ul><h3 id="斯坦福大学公开课">斯坦福大学公开课</h3><ul><li>Stanford CS231N</li><li>Stanford CS223B</li></ul><h2 id="机器学习、深度学习">机器学习、深度学习</h2><ul><li><p>《机器学习》周志华 著<a href="https://pan.baidu.com/s/1KefCMHg8yfRWf4HkxZJvZw" target="_blank" rel="noopener">PDF</a></p></li><li><p>《统计学习方法 第二版》李航 著<a href="https://vdisk.weibo.com/s/sLX7IJK7Id7D" target="_blank" rel="noopener">PDF</a></p></li><li><p>《统计机器学习导论[日]》</p></li><li><p>《Deep Learning》(花书)<a href="https://pan.baidu.com/s/1jIkLkIM" target="_blank" rel="noopener">PDF</a></p></li><li><p>《图解机器学习[日]》<a href="https://pan.baidu.com/s/1kUCWXYB" target="_blank" rel="noopener">PDF</a></p></li><li><p><strong>编程</strong></p></li><li><p>《Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow》第二版(快速上手)<a href="http://gen.lib.rus.ec/book/index.php?md5=064323EFDE7FEF1A89B38E60F508E324" target="_blank" rel="noopener">PDF</a></p></li><li><p>《深度有趣》在线项目<a href="https://github.com/Honlan/DeepInterests" target="_blank" rel="noopener">PDF</a></p></li><li><p>《21个项目玩转深度学习：基于TensorFlow的实践讲解》<a href="http://vdisk.weibo.com/s/b643JsWsSRm51" target="_blank" rel="noopener">PDF</a></p></li><li><p>《TensorFlow：实战Google深度学习框架》</p></li></ul><h2 id="强化学习">强化学习</h2><ul><li><p>《强化学习精要：核心算法与TensorFlow实现》<a href="">PDF</a></p></li><li><p>《Reinforcement Learning：An Introduction》第2版<a href="https://pan.baidu.com/s/134Pnt96xuzCKDtjeGH0vrQ" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Algorithm for Reinforcement Learning》by Csaba Szepesvari<a href="https://vdisk.weibo.com/s/z0ugys1Iva5bM" target="_blank" rel="noopener">PDF</a></p></li></ul><h2 id="计算机科学兴趣读物">计算机科学兴趣读物</h2><ul><li><p>《数学之美》<a href="https://pan.baidu.com/s/1jGFY0rc" target="_blank" rel="noopener">PDF</a></p></li><li><p>《离散数学及其应用》<a href="https://pan.baidu.com/s/11D8P7" target="_blank" rel="noopener">PDF</a></p></li><li><p>《具体数学》<a href="https://u15169360.ctfile.com/fs/15169360-371634232" target="_blank" rel="noopener">PDF</a></p></li><li><p>《组合数学》<a href="https://pan.baidu.com/s/1wtZY" target="_blank" rel="noopener">PDF</a></p></li><li><p>《深入理解计算机系统》<a href="https://pan.baidu.com/s/12hlxZ" target="_blank" rel="noopener">PDF</a></p></li><li><p>《一个64位操作系统的设计与实现》</p></li><li><p>《计算机科学导论》</p></li></ul><h2 id="大数据">大数据</h2><ul><li><p>《Spark快速大数据分析[美]》<a href="https://u15169360.ctfile.com/fs/15169360-371377135" target="_blank" rel="noopener">PDF</a></p></li><li><p>《MongoDB权威指南》第2版<a href="https://pan.baidu.com/s/1qWlDhbI" target="_blank" rel="noopener">PDF</a></p></li><li><p>《数据算法：Hadoop/Spark大数据处理技巧》<a href="http://book.ucdrs.superlib.net/views/specific/2929/bookDetail.jsp?dxNumber=000016213214&amp;d=727B0D16DC1C0DE09BEC935AD4DD551F" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Hadoop权威指南：大数据的存储与分析》<a href="http://book.ucdrs.superlib.net/views/specific/2929/bookDetail.jsp?dxNumber=000016651684&amp;d=8DF3F5F0A7B975F0F7AC6B3CBEB3026F" target="_blank" rel="noopener">PDF</a></p></li><li><p>《高性能MySQL》第3版<a href="https://pan.baidu.com/s/1o6jt2WE" target="_blank" rel="noopener">PDF</a></p></li></ul><h2 id="数据挖掘">数据挖掘</h2><ul><li><p>《数据挖掘导论》第2版<a href="http://home.ustc.edu.cn/~jw1992/book/introduction_to_DM.pdf" target="_blank" rel="noopener">PDF</a></p></li><li><p>《Python数据分析与挖掘实战》<a href="https://vdisk.weibo.com/s/b643JsWsSRlWe" target="_blank" rel="noopener">PDF</a></p></li><li><p>《数据挖掘与预测分析》(R语言)<a href="http://book.ucdrs.superlib.net/views/specific/2929/bookDetail.jsp?dxNumber=000016524217&amp;d=8CE4E3CD71147B5314575AA8A9AB319C" target="_blank" rel="noopener">PDF</a></p></li></ul><blockquote><p>书很多，请不要把时间浪费在选择哪本书上。如果你选择困难，就按顺序读吧。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回首2019</title>
      <link href="/2019/11/04/2019/2019-nian-zhong-zong-jie/"/>
      <url>/2019/11/04/2019/2019-nian-zhong-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>临近着年底，将2019的工作进行总结。</p><p>总的来说，今年还是做了不少工作，年初印尼开了头，在马来西亚也做了不少关于计算机专业必备知识素养的学习。</p><h1>工作</h1><p>首先最重要的就是三个月有余的找工作过程。</p><p>我的过程还是挺艰辛的。一开始也走了不少冤枉路。前前后后也看了不少小大公司。</p><p>还是去了传统大型日企。</p><h1>学习</h1><p>挖的坑</p><p>CMU的《数据库》</p><p>《</p><p>暑假又开始对数学进一步学习。</p><p>《离散数学》</p><p>《近世数学》</p><p>《高等代数》</p><p>《矩阵分析》</p><p>《凸优化》</p><p>基本看完的书籍</p><p>《</p><h1>研究</h1><p>今年也是自己毕业之年。</p><p>的确深感自己研究能力的欠缺。对一个完整的研究</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB 实现函数卷积演示动画</title>
      <link href="/2019/11/04/2019/matlab-shi-xian-juan-ji-cao-zuo/"/>
      <url>/2019/11/04/2019/matlab-shi-xian-juan-ji-cao-zuo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>前置知识</h1><h2 id="图解法求卷积">图解法求卷积</h2><p>函数的卷积:<br>$$<br>f_1(t) * f_2(t) = \int _{-\infty}^{\infty} f_1(\tau)f_2(t-\tau) d\tau<br>$$</p><p>使用图解法，将卷积运算中一些抽象的关系形象化。具体有以下几个步骤：</p><ol><li>换元：将横坐标变元由 $t$ 变换为 $τ$：$f_1(t)→f_1(τ)，f_2(t)→f_2(τ)$</li><li>固定其中一个信号（如 $f_2(τ)$），对另一个信号关于纵轴反折：$f_1(τ)→f_1(−τ)$</li><li>位移：将反折后的信号做位移，位移量是 $f_1(-\tau) \to f_1(t-\tau)$。首先将 $f_1$ 左移到与 $f_2$不重合的位置</li><li>增大 t，将 $f_1$向右移动，使得 $f_1(t−τ)$和 $f_2(τ)$ 发生重叠，将两信号重叠的部分相乘：$f_1(t−τ)f_2(τ)$</li><li>积分：两个信号在该点重叠部分的面积$\int _{-\infty} ^{\infty}f_1(t-\tau)f_2(\tau) d\tau$ 即为 $f_1∗f_2$ 在点 t 处的函数值</li></ol><h1>实现</h1><p>让我们首先定义一下我们要卷积的函数。假设我们有了两个函数$f_1(t) = u(t) - u(t-2), f_2(t) = u(t-1) - u(t-3)$, 要用图解法求 $f_1∗f_2$.</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">syms t;f1 = 1/2 * t * (heaviside(t) - heaviside(t - 2));f2 = (1 - 1/2 * (abs(t))) * (heaviside(t + 2) - heaviside(t - 2));d = 0.1;t1 = 0 : d : 2;t2 = -2 : d : 2;convolution(f1, f2, t1, t2, d);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="img/000.jpg" alt=""></p><p>实现卷积函数</p><pre class="line-numbers language-language-matlab"><code class="language-language-matlab">function [] = convolution(f1, f2, t1, t2, d)    syms t tao;         % 定义用于符号计算的变量    figure;             % 在一个新的窗体上执行绘图    grid on;    hold on;            % 因为要多用多次 plot 和 fplot，所以要打开 hold        % 以下计算，可参照连续信号的卷积函数    time_start = t1(1) + t2(1);                              % 计算卷积结果序列非 0 值的起始位置    time_length = length(t1) + length(t2) - 2;               % 计算卷积结果序列非 0 值得宽度        f = time_start;                          % 时域起始位置 from    e = time_start + time_length * d;        % 时域终止位置 end    ymin = -5;    ymax = 5;        f11 = subs(f1, t, t - tao);             % 对 f1 进行换元、反折和位移：f1(t) => f1(tau) => f1(-tau) => f1(t-tau)    fplot(f2, [f, e]);                      % f2 是固定的，可以先画到图上        vec = f : d : e;                        % 生成卷积结果的时域向量    p1 = fplot(f2, [f, e]);                 % 定义 p1 绘图句柄    dt = [0];     ft = [0];        % 循环绘图动画，对于卷积结果的时域向量中的每一个 t，都绘制一张该时刻的图    for i = 1 : 1 : length(vec)        f12 = subs(f11, {t tao}, {vec(i) t});   % 令 t0 = vec(i)，此时 f12 = f1(t0-tau)，即位移量为 t0        f13 = f12 * f2;                         % 计算位移 t0 后的 f1 与 f2 的相乘结果        delete(p1);                             % 先删除上一个 f12 的图像        p1 = fplot(f12, [f e]);                 % 绘制新的 f12        axis([f, e, ymin, ymax]);        set(p1, 'Color', 'r');        f14 = int(f13, f, e);                   % 计算积分值，即为在 t 时刻的 f1*f2 值        % 为了使得绘出的图像平滑，将当前的 (t, f14) 添加到数组（向量）中，然后调用 plot 就可以绘出光滑的曲线        % 否则，只调用 plot(t, f14) 只能绘出散点图        % 并且，填充曲线下方到 x 轴的区域。根据简单的几何知识，因为间隔 d 足够小，所以只要填充一个梯形即可        % 设当前的 t 值为 v(i)，当前函数值为 f(i)，那么只要填充梯形 (v(i), f(i)), (v(i), 0), (v(i-1), 0), (v(i-1), f(i-1)) 即可        p2 = fill([dt(length(dt)), dt(length(dt)), vec(i), vec(i)], [0, ft(length(ft)), f14, 0], 'y');        set(p2, 'LineStyle', 'none');        dt = [dt vec(i)];        ft = [ft f14];        plot(dt, ft, '-b');                     % 最后绘制图形        axis([f e ymin ymax]);                pause(0.0001);                          % 短暂暂停，产生动画    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019/博士愿景</title>
      <link href="/2019/11/04/2019/bo-shi-yuan-jing/"/>
      <url>/2019/11/04/2019/bo-shi-yuan-jing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>1</th><th>54</th><th>Delft University of Technology</th><th>代尔夫特理工大学</th></tr></thead><tbody><tr><td>2</td><td>58</td><td>University of Amsterdam</td><td>阿姆斯特丹大学</td></tr><tr><td>3</td><td>104</td><td>Eindhoven University of Technology</td><td>埃因霍芬理工大学</td></tr><tr><td>4</td><td>109</td><td>Leiden University</td><td>莱顿大学</td></tr><tr><td>4</td><td>109</td><td>Utrecht University</td><td>乌得勒支大学</td></tr><tr><td>6</td><td>113</td><td>University of Groningen</td><td>格罗宁根大学</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>179</td><td>University of Twente</td><td>特温特大学</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>218</td><td>Vrije Universiteit Amsterdam</td><td>阿姆斯特丹自由大学https://www.vu.nl/en/research/taking-phd/application-admission-and-funding/application/index.aspx</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1>英国奥斯特大学</h1><p>雅思6.5</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/04/2019/shu-mei-pai-shang-shou/"/>
      <url>/2019/11/04/2019/shu-mei-pai-shang-shou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>VNC方式连接</h1><p>树莓派VNC服务器</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">sudo apt-get updatesudo apt-get upgradesudo apt-get install tightvncservertightvncserver#开启服务器vncserver :1#获得IP Address.hostname -I<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Mac vnc连接</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">#Finder  -> go -> connect to servervnc://ip:5901 #netstat -nlt 确定端口是否被占用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1>ssh方式连接</h1><p>树莓派配置中开启ssh连接。</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">ssh pi@ip#密码默认raspberry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用openni2</li></ul><p><a href="https://github.com/occipital/OpenNI2/" target="_blank" rel="noopener">https://github.com/occipital/OpenNI2/</a></p><p>To make it compile i changed the CFLAGS in:<br><code>OpenNI2/ThirdParty/PSCommon/BuildSystem/Platform.Arm</code></p><pre><code>CFLAGS += -mtune=arm1176jzf-s -mfpu=vfp -mfloat-abi=hard</code></pre><p>and had to disable neon:</p><pre><code>#DEFINES += XN_NEON</code></pre><p>编译成功后，将所需要so动态库放到<code>\usr\local\lib</code>, 通过cmake导入。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2019/10/15/2019/hexo-bo-ke-da-jian/"/>
      <url>/2019/10/15/2019/hexo-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来自己已经有一个jekyll博客了，但是偶然看见<a href="https://www.hahack.com/" target="_blank" rel="noopener">这个大佬</a>的笔记wiki，就简直看到了自己想要的。加之其配色代码风格，与自己心目中相符，断然决定另起炉灶，放弃陪伴几个月的博客，就让它消失在岁月尘光中。</p><h1>准备工作</h1><ul><li>Prepare</li></ul><p>下载nvm，node。注意环境变量。</p><ul><li>Hexo</li></ul><p>安装Hexo，见<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">官网</a>.</p><blockquote><p>⚠️这个问题</p><p>Mac / Linux</p><p>If you encounter <code>EACCES</code> permission error when trying to install Hexo, please follow <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">the workaround</a> provided by npmjs; overriding with root/sudo is highly discouraged.</p></blockquote><p>一些github和hexo初始化<a href="https://www.jianshu.com/p/cb0750324e26" target="_blank" rel="noopener">操作</a>。</p><pre class="line-numbers language-language-shell"><code class="language-language-shell">hexo inithexo install hexo g hexo shexo d #部署到github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>主题</h1><h2 id="wixo主题">wixo主题</h2><p>为了增加wiki的layout，着实花了一番功夫。</p><p>最后其实很简单搞定。</p><ol><li>新建wiki页面</li></ol><p><code>hexo new page wiki</code></p><p>然后你会发现source里面多了个目录about，<a href="http://xn--index-mn1hs99lfr9dzrk.md" target="_blank" rel="noopener">里面有个index.md</a>。其实你也可以手动建立。页面的格式和文章一样。接着把链接加上,在主题下的<code>_config.yml</code>里面的menu一项，添加wiki</p><ol start="2"><li>复制wixo中的相关代码</li></ol><p><a href="https://github.com/wzpan/hexo-theme-wixo/blob/3d3eeff9dd00f9c589a5da515d70c891bf6ca4fc/layout/_partial/index.ejs" target="_blank" rel="noopener">项目的index代码</a>复制到freemind的layout，改名为wiki。</p><ol start="3"><li>文章在wiki页面显示方式</li></ol><p>原wixo项目所有文章都会显示。为了避免，参考<a href="http://perthcharles.github.io/2015/01/17/how-to-hack-hexo/" target="_blank" rel="noopener">这篇</a>，在wiki.ejs中15行，37行分布添加</p><pre class="line-numbers language-language-ejs"><code class="language-language-ejs"><% if(cat.name.substring(0, 5) == 'wiki-') { %><% } %><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="matery">matery</h2><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-19" target="_blank" rel="noopener">主题属性</a></p><p>颜值即是正义。</p><ul><li>插件</li></ul><pre class="line-numbers language-language-bash"><code class="language-language-bash">sudo npm install hexo-deployer-git --save npm i -S hexo-prism-pluginnpm install hexo-generator-search --savenpm i hexo-permalink-pinyin --savenpm i --save hexo-wordcountnpm install hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>写作</h1><h2 id="准备">准备</h2><p>首页显示摘要，next主题的官方就有给出<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95" target="_blank" rel="noopener">三种方法</a>，本文详细介绍的就是其中一种。并附上个人的markdown文章头部模板。</p><h3 id="摘要">摘要</h3><ol><li>在文章中使用\手动进行截断，Hexo 提供的方式(推荐)</li><li>在文章的 <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">front-matter</a> 中添加 description，并提供文章摘录</li><li>自动形成摘要，在主题配置文件中添加，默认截取的长度为 150字符，可以根据需要自行设定：</li></ol><pre><code>auto_excerpt:  enable: true  length: 150</code></pre><h3 id="文章模板">文章模板</h3><pre><code>---title: git的基本使用date: 2017-01-24categories:- 学习- gittags:  - git---摘要内容......&lt;!-- more --&gt;</code></pre><h2 id="样式">样式</h2><h3 id="突出重要的文字">突出重要的文字</h3><pre class="line-numbers language-language-html"><code class="language-language-html"><font color="green">xxx</font><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="green"><strong>该标签可以表示条目的等级，使用的时候一定要注意和后边内容留有空格。</strong></font></p><pre class="line-numbers language-language-html"><code class="language-language-html"><span style="background:#CA8EFF;"><font color="#FDFFFF" size ="2">xxx</font></span>`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><span style="background:#CA8EFF;"><font color="#FDFFFF" size ="2">主题配置文件</font></span></p><h3 id="标签">标签</h3><p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins.html</a></p><ul><li>引用块</li></ul><p>在文章中插入引言，可包含作者、来源和标题。</p><pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %}</code></pre><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><ul><li>视频</li></ul><pre><code>{% youtube video_id %}</code></pre><h1>Troubleshoot</h1><h2 id="部署后没有样式">部署后没有样式</h2><p>修改config文件，设置url即可</p><pre class="line-numbers language-language-md"><code class="language-language-md">url: [https://XXX.github.io/XXX.github.io/](https://xxx.github.io/XXX.github.io/)root: /XXX.github.io/permalink: :year/:month/:day/:title/permalink_defaults:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="博客分类标签layout没有内容">博客分类标签layout没有内容</h2><p><code>hexo new page xxx</code></p><p>创建layout页面, categories，tags等。source文件夹下生成index文件。</p><p>需要额外添加，如下：</p><pre class="line-numbers language-language-md"><code class="language-language-md">title: tagsdate: 2019-11-02 15:42:36type: "tags" layout: "tags"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="hexo中插入数学公式">hexo中插入数学公式</h2><pre><code>$ npm install hexo-math --save</code></pre><p>在站点配置文件 <em>_config.yml</em> 中添加：</p><pre><code>math:  engine: 'mathjax' # or 'katex'  mathjax:    # src: custom_mathjax_source    config:      # MathJax config</code></pre><p>在 next 主题配置文件中 <em>themes/next-theme/_config.yml</em> 中将 mathJax 设为 true:</p><pre><code># MathJax Supportmathjax:  enable: true  per_page: false  cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</code></pre><p><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">http://stevenshi.me/2017/06/26/hexo-insert-formula/</a></p><h2 id="wixo-中支持-Mathjax">wixo 中支持 Mathjax</h2><p>在 hexo 中，你会发现我们不能用 <code>Latex</code> 语法来书写数学公式，这对于书写学术博客来说是很大的不便，因为我们会经常碰到很多的数学公式推导，但是我们可以通过安装第三方库来解决这一问题。</p><p>第一步： 使用Kramed代替 Marked</p><p><code>hexo</code> 默认的渲染引擎是 <code>marked</code>，但是 <code>marked</code> 不支持 <code>mathjax</code>。 <code>kramed</code> 是在 <code>marked</code> 的基础上进行修改。我们在工程目录下执行以下命令来安装 <code>kramed</code>.</p><pre><code>npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save</code></pre><p>然后，更改/node_modules/hexo-renderer-kramed/lib/renderer.js，更改：</p><pre><code>// Change inline math rulefunction formatText(text) {    // Fit kramed's rule: $$ + \1 + $$    return text.replace(/`\$(.*?)\$`/g, '$$$$$1$$$$');}</code></pre><p>为：</p><pre><code>// Change inline math rulefunction formatText(text) {    return text;}</code></pre><p>第二步: 停止使用 hexo-math</p><p>首先，如果你已经安装 <code>hexo-math</code>, 请卸载它：</p><pre><code>npm uninstall hexo-math --save</code></pre><p>然后安装 <a href="https://github.com/phoenixcw/hexo-renderer-mathjax" target="_blank" rel="noopener">hexo-renderer-mathjax</a> 包：</p><pre><code>npm install hexo-renderer-mathjax --save</code></pre><p>第三步: 更新 Mathjax 的 CDN 链接</p><p>首先，打开/node_modules/hexo-renderer-mathjax/mathjax.html</p><p>然后，把``更改为：</p><pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</code></pre><p>第四步: 更改默认转义规则</p><p>因为 <code>hexo</code> 默认的转义规则会将一些字符进行转义，比如 <code>_</code> 转为 ``, 所以我们需要对默认的规则进行修改.<br>首先， 打开&lt;path-to-your-project/node_modules/kramed/lib/rules、inline.js,</p><p>然后，把:</p><pre><code>escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,</code></pre><p>更改为:</p><pre><code>escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</code></pre><p>把</p><pre><code>em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><p>更改为:</p><pre><code>em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><p>第五步: 开启mathjax</p><p>在主题 <code>_config.yml</code> 中开启 Mathjax， 找到 <code>mathjax</code> 字段添加如下代码：</p><pre><code>mathjax:    enable: true</code></pre><p>这一步可选，在博客中开启 <code>Mathjax</code>，， 添加以下内容：</p><pre><code>---title: Testing Mathjax with Hexocategory: Uncategorizeddate: 2017/05/03mathjax: true---</code></pre><p>通过以上步骤，我们就可以在 <code>hexo</code> 中使用 <code>Mathjax</code> 来书写数学公式。</p><h1>魔改</h1><p><a href="https://pengloo53.gitbooks.io/hexo/content/" target="_blank" rel="noopener">https://pengloo53.gitbooks.io/hexo/content/</a></p><h2 id="插入音视频">插入音视频</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27530429&auto=1&height=66"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用谷歌API训练自己检测器</title>
      <link href="/2019/07/03/2019/2019-07-2-shi-yong-gu-ge-api-xun-lian-zi-ji-jian-ce-qi/"/>
      <url>/2019/07/03/2019/2019-07-2-shi-yong-gu-ge-api-xun-lian-zi-ji-jian-ce-qi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>使用谷歌API训练自己检测器</h1><h1>0. 快速开始</h1><p>Setup:</p><ul><li><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/installation.md" target="_blank" rel="noopener">Installation</a></li></ul><p>Quick Start:</p><ul><li><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/object_detection_tutorial.ipynb" target="_blank" rel="noopener">Quick Start: Jupyter notebook for off-the-shelf inference</a></li><li><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/running_pets.md" target="_blank" rel="noopener">Quick Start: Training a pet detector</a></li></ul><p>推荐文件夹格式：</p><p>annotations — 标注xml文件</p><p>data — 转化后tf record文件</p><p>images — 原数据集</p><p>training  — 训练模型以及配置文件</p><h1>1. 制作图像数据集</h1><h2 id="数据来源">数据来源</h2><p><a href="https://images.google.com/" target="_blank" rel="noopener">Google Images</a> and <a href="https://pixabay.com/" target="_blank" rel="noopener">Pixabay</a></p><ul><li><p>jpeg or png</p></li><li><p>bounding boxes (<code>xmin, ymin, xmax, ymax</code>)</p></li></ul><h2 id="数据标注工具">数据标注工具</h2><p>几种格式：PASCAL VOC format， COCO</p><ul><li><p><a href="http://www.robots.ox.ac.uk/~vgg/software/via/" target="_blank" rel="noopener">VIA (VGG Image Annotator)</a></p><blockquote><p>because of its simplicity. It’s a single HTML file that you download and open in a browser.</p></blockquote></li><li><p><a href="https://github.com/tzutalin/labelImg" target="_blank" rel="noopener">LabelImg</a></p><blockquote><p>saved as XML files in the PASCAL VOC format</p></blockquote></li></ul><p><a href="https://gist.github.com/seaside2mm/5b3ee02404f46601f43ff012f679d7bb" target="_blank" rel="noopener">XML 转换 CSV格式</a></p><ul><li><a href="https://github.com/christopher5106/FastAnnotationTool" target="_blank" rel="noopener">FIAT (Fast Image Data Annotation Tool)</a></li></ul><h2 id="csv数据集划分">csv数据集划分</h2><p><a href="https://gist.github.com/seaside2mm/8cd6c846936a441489bc310d69b1d42a" target="_blank" rel="noopener">划分训练和测试</a></p><h2 id="TFRecord数据格式">TFRecord数据格式</h2><p>生成方法：</p><p><a href="http://host.robots.ox.ac.uk/pascal/VOC/" target="_blank" rel="noopener">PASCAL VOC dataset</a></p><p><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/dataset_tools/create_pascal_tf_record.py" target="_blank" rel="noopener">create_pascal_tf_record.py</a></p><p>图像格式转换</p><p><a href="http://imagemagick.org/#" target="_blank" rel="noopener">ImageMagick</a></p><h1>2. 训练模型</h1><p>利用 <a href="https://research.googleblog.com/2017/06/supercharge-your-computer-vision-models.html" target="_blank" rel="noopener">TensorFlow’s new Object Detector API</a>进行模型训练。</p><h2 id="更改配置文件">更改配置文件</h2><ul><li>选择具体NN模型更改 <a href="https://github.com/tensorflow/models/tree/master/research/object_detection/samples/configs" target="_blank" rel="noopener">config files</a></li></ul><p><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/configuring_jobs.md" target="_blank" rel="noopener">object detection training pipeline</a>.</p><pre><code>tf_record_input_reader {  input_path: &quot;/usr/home/username/data/train.record&quot;}label_map_path: &quot;/usr/home/username/data/label_map.pbtxt&quot;</code></pre><ul><li>label map</li></ul><p><a href="https://github.com/tensorflow/models/tree/master/research/object_detection/data" target="_blank" rel="noopener">选择相对应label map</a>. 比如，只有一个label时：</p><pre><code>item {  id: 1  name: 'person'}</code></pre><h2 id="Pre-trained-model-checkpoint">Pre-trained model checkpoint</h2><p>选择已经训练好的模型进行模型迁移，减少计算量。可选择项。 <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md" target="_blank" rel="noopener">several model checkpoint</a></p><h2 id="训练">训练</h2><ul><li>Training can be either done <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/running_locally.md" target="_blank" rel="noopener">locally</a> or on the <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/running_on_cloud.md" target="_blank" rel="noopener">cloud</a> (AWS, Google Cloud etc.). If you have GPU (at least more than 2 GB) at home then you can do it locally otherwise I would recommend to go with the cloud. In my case, I went with <a href="http://cloud.google.com/" target="_blank" rel="noopener">Google Cloud</a> this time and essentially followed all the steps described in <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/running_on_cloud.md" target="_blank" rel="noopener">their documentation</a>.</li><li>For Google Cloud, you need to define a YAML configuration file. A <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/samples/cloud/cloud.yml" target="_blank" rel="noopener">sample file is also provided</a> and I basically just took the default values.</li><li>It is also recommended during the training to start the evaluation job. You can then monitor the process of the training and evaluation jobs by running <a href="https://www.tensorflow.org/get_started/summaries_and_tensorboard" target="_blank" rel="noopener">Tensorboard</a> on your local machine.</li></ul><h1>3. 导出模型</h1><p>copy the model checkpoints from the Google Cloud bucket to my local machine and then used the <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/exporting_models.md" target="_blank" rel="noopener">provided script</a> to export the model.</p><p>After export, you should see the directory ${EXPORT_DIR} containing the following:</p><ul><li>saved_model/, a directory containing the saved model format of the exported model</li><li>frozen_inference_graph.pb, the frozen graph format of the exported model</li><li>model.ckpt.*, the model checkpoints used for exporting</li><li>checkpoint, a file specifying to restore included checkpoint files</li><li>pipeline.config, pipeline config file for the exported model</li></ul><h1>参考</h1><p><a href="https://github.com/tensorflow/models/tree/master/research/object_detection" target="_blank" rel="noopener">https://github.com/tensorflow/models/tree/master/research/object_detection</a></p><p><a href="https://towardsdatascience.com/how-to-train-your-own-object-detector-with-tensorflows-object-detector-api-bec72ecfe1d9" target="_blank" rel="noopener">https://towardsdatascience.com/how-to-train-your-own-object-detector-with-tensorflows-object-detector-api-bec72ecfe1d9</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程</title>
      <link href="/2019/04/29/2019/threading/"/>
      <url>/2019/04/29/2019/threading/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>多线程</h1><pre class="line-numbers language-language-python"><code class="language-language-python">import threading#获取已激活的线程数threading.active_count()#查看所有线程信息threading.enumerate()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[&lt;_MainThread(MainThread, started 4320838528)&gt;, &lt;Thread(Thread-2, started daemon 123145567674368)&gt;, &lt;ParentPollerUnix(Thread-1, started daemon 123145584513024)&gt;, &lt;Heartbeat(Thread-3, started daemon 123145572929536)&gt;, &lt;HistorySavingThread(IPythonHistorySavingThread, started 123145579257856)&gt;]</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#添加线程，threading.Thread()接收参数target代表这个线程要完成的任务，需自行定义def thread_job():    print('This is a thread of %s' % threading.current_thread())def main():    thread = threading.Thread(target=thread_job,)   # 定义线程     thread.start()  # 让线程开始工作    if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>This is a thread of &lt;Thread(Thread-6, started 123145589768192)&gt;</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python"> #T1 线程工作的耗时增加.import threadingimport timedef thread_job():    print("T1 start\n")    for i in range(10):        time.sleep(0.1) # 任务间隔0.1s    print("T1 finish\n")added_thread = threading.Thread(target=thread_job, name='T1')# added_thread.start()print("all done\n")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>all done</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#线程任务还未完成便输出all done。如果要遵循顺序，可以在启动线程后对它调用joinadded_thread.start()added_thread.join()print("all done\n")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>T1 startT1 finishall done</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">import threadingimport timedef thread_job():    print('T1 start\n')    for i in range(10):        time.sleep(0.1)    print('T1 finish\n')def T2_job():    print('T2 start\n')    print('T2 finish\n')def main():    added_thread = threading.Thread(target=thread_job, name='T1')    thread2 = threading.Thread(target=T2_job, name='T2')    added_thread.start()    thread2.start()    thread2.join()    added_thread.join()    print('all done\n')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#储存进程结果 Queue#代码实现功能，将数据列表中的数据传入，使用四个线程处理，将结果保存在Queue中，线程执行完后，从Queue中获取存储的结果import threadingimport timefrom queue import Queuedef job(l,q):    """定义一个被多线程调用的函数    函数的参数是一个列表l和一个队列q，函数的功能是，对列表的每个元素进行平方计算，将结果保存在队列中    """    for i in range (len(l)):        l[i] = l[i]**2    q.put(l)   ##多线程调用的函数不能用return返回值def multithreading():    """定义一个多线程函数    在多线程函数中定义一个Queue，用来保存返回值，代替return，定义一个多线程列表，初始化一个多维数据列表，用来处理    """    q = Queue()  ##q中存放返回值，代替return的返回值    threads = []    data = [[1,2,3],[3,4,5],[4,4,4],[5,5,5]]    for i in range(4):   ##定义四个线程        t = threading.Thread(target=job,args=(data[i],q))  ##Thread首字母要大写，被调用的job函数没有括号，只是一个索引，参数在后面        t.start()        threads.append(t)   ##把每个线程append到线程列表中    for thread in threads:   #分别join四个线程到主线程        thread.join()    results = []    for _ in range(4):  #定义一个空的列表results，将四个线运行后保存在队列中的结果返回给空列表results        results.append(q.get())    print(results)if __name__ == '__main__':    multithreading()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[[1, 4, 9], [9, 16, 25], [16, 16, 16], [25, 25, 25]]</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#测试 GIL, Global Interpreter Lock (GIL). 这个东西让 Python 还是一次性只能处理一个东西.#我们创建一个 job, 分别用 threading 和 一般的方式执行这段程序. 并且创建一个 list 来存放我们要处理的数据. #在 Normal 的时候, 我们这个 list 扩展4倍, 在 threading 的时候, 我们建立4个线程, 并对运行时间进行对比.import threadingfrom queue import Queueimport copyimport timedef job(l, q):    res = sum(l)    q.put(res)def multithreading(l):    q = Queue()    threads = []    for i in range(4):        t = threading.Thread(target=job, args=(copy.copy(l), q), name='T%i' % i)        t.start()        threads.append(t)    [t.join() for t in threads]    total = 0    for _ in range(4):        total += q.get()    print(total)def normal(l):    total = sum(l)    print(total)if __name__ == '__main__':    l = list(range(1000000))    s_t = time.time()    normal(l*4)    print('normal: ',time.time()-s_t)    s_t = time.time()    multithreading(l)    print('multithreading: ', time.time()-s_t)    #如果你成功运行整套程序, 你大概会有这样的输出. 我们的运算结果没错, 所以程序 threading 和 Normal 运行了一样多次的运算.#但是我们发现 threading 却没有快多少, 按理来说, 我们预期会要快3-4倍, 因为有建立4个线程, 但是并没有. 这就是其中的 GIL 在作怪.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>1999998000000normal:  0.130269050598144531999998000000multithreading:  0.13005995750427246</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#不使用 Lock 的情况import threadingdef job1():    global A    for i in range(10):        A+=1        print('job1',A)def job2():    global A    for i in range(10):        A+=10        print('job2',A)if __name__== '__main__':    lock=threading.Lock()    A=0    t1=threading.Thread(target=job1)    t2=threading.Thread(target=job2)    t1.start()    t2.start()    t1.join()    t2.join()    #使用 Lock 的情况#lock在不同线程使用同一共享内存时，能够确保线程之间互不影响，#使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， #确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。import threadingdef job1():    global A,lock    lock.acquire()    for i in range(10):        A+=1        print('job1',A)    lock.release()def job2():    global A,lock    lock.acquire()    for i in range(10):        A+=10        print('job2',A)    lock.release()if __name__== '__main__':    lock=threading.Lock()    A=0    t1=threading.Thread(target=job1)    t2=threading.Thread(target=job2)    t1.start()    t2.start()    t1.join()    t2.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>job1 1job1 2job1 3job1 4job1 5job1 6job1 7job1 8job1 9job1 10job2 20job2 30job2 40job2 50job2 60job2 70job2 80job2 90job2 100job2 110job1 1job1 2job1 3job1 4job1 5job1 6job1 7job1 8job1 9job1 10job2 20job2 30job2 40job2 50job2 60job2 70job2 80job2 90job2 100job2 110</code></pre><h1>多进程</h1><pre class="line-numbers language-language-python"><code class="language-language-python">import multiprocessing as mpimport threading as tddef job(a,d):    print('aaaaa')t1 = td.Thread(target=job,args=(1,2))p1 = mp.Process(target=job,args=(1,2))t1.start()p1.start()t1.join()p1.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>aaaaaaaaaa</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#存储进程输出 Queue#Queue的功能是将每个核或线程的运算结果放在队里中， 等到每个线程或核运行完毕后再从队列中取出结果， 继续加载运算。#原因很简单, 多线程调用的函数不能有返回值, 所以使用Queue存储多个线程运算的结果import multiprocessing as mpdef job(q):    res=0    for i in range(1000):        res+=i+i**2+i**3    q.put(res)    #queueif __name__=='__main__':    q = mp.Queue()    p1 = mp.Process(target=job,args=(q,))    p2 = mp.Process(target=job,args=(q,))    p1.start()    p2.start()    p1.join()    p2.join()    res1 = q.get()    res2 = q.get()    print(res1+res2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>499667166000</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#效率对比 threading & multiprocessingimport multiprocessing as mpimport threading as tdimport timedef job(q):    res = 0    for i in range(1000000):        res += i+i**2+i**3    q.put(res) # queuedef multicore():    q = mp.Queue()    p1 = mp.Process(target=job, args=(q,))    p2 = mp.Process(target=job, args=(q,))    p1.start()    p2.start()    p1.join()    p2.join()    res1 = q.get()    res2 = q.get()    print('multicore:' , res1+res2)def normal():    res = 0    for _ in range(2):        for i in range(5000000):            res += i+i**2+i**3    print('normal:', res)def multithread():    q = mp.Queue()    t1 = td.Thread(target=job, args=(q,))    t2 = td.Thread(target=job, args=(q,))    t1.start()    t2.start()    t1.join()    t2.join()    res1 = q.get()    res2 = q.get()    print('multithread:', res1+res2)if __name__ == '__main__':    st = time.time()    normal()    st1= time.time()    print('normal time:', st1 - st)    multithread()    st2 = time.time()    print('multithread time:', st2 - st1)    multicore()    print('multicore time:', time.time()-st2)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>normal: 312499958333345833330000000normal time: 12.966257810592651multithread: 499999666667166666000000multithread time: 2.565357208251953multicore: 499999666667166666000000multicore time: 1.4095678329467773</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#进程池 Pool#有了池子之后，就可以让池子对应某一个函数，我们向池子里丢数据，池子就会返回函数返回的值。 #Pool和之前的Process的不同点是丢向Pool的函数有返回值，而Process的没有返回值。#接下来用map()获取结果，在map()中需要放入函数和需要迭代运算的值，然后它会自动分配给CPU核，返回结果import multiprocessing as mpdef job(x):    return x*xdef multicore():    """自定义核数量    我们怎么知道Pool是否真的调用了多个核呢？我们可以把迭代次数增大些，然后打开CPU负载看下CPU运行情况    打开CPU负载(Mac)：活动监视器 > CPU > CPU负载(单击一下即可)    Pool默认大小是CPU的核数，我们也可以通过在Pool中传入processes参数即可自定义需要的核数量，    """    pool = mp.Pool(processes=2)    res = pool.map(job, range(10))    print(res)    #apply_async()中只能传递一个值，它只会放入一个核进行运算，但是传入值时要注意是可迭代的，所以在传入值后需要加逗号, 同时需要用get()方法获取返回值    res = pool.apply_async(job, (2,))    print(res.get())    #同样在取出值时需要一个一个取出来    multi_res =[pool.apply_async(job, (i,)) for i in range(10)]    print([res.get() for res in multi_res])if __name__ == '__main__':    multicore()    #总结 #Pool默认调用是CPU的核数，传入processes参数可自定义CPU核数#map() 放入迭代参数，返回多个结果#apply_async()只能放入一组参数，并返回一个结果，如果想得到map()的效果需要通过迭代"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]4[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><pre class="line-numbers language-language-python"><code class="language-language-python">#共享内存 shared memory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme Theme introduction</title>
      <link href="/2018/09/07/2020/mo-ban/"/>
      <url>/2018/09/07/2020/mo-ban/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>1</h1><h2 id="2">2</h2><h3 id="3">3</h3>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学自学指南</title>
      <link href="/2017/10/01/2019/ji-suan-ji-ke-xue-zi-xue-zhi-nan/"/>
      <url>/2017/10/01/2019/ji-suan-ji-ke-xue-zi-xue-zhi-nan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://cslearner.cn/" target="_blank" rel="noopener">路线参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
